
(* Operations generated by the compiler. 
 * 
 * Semantic of comments below:
 *  - Arguments on stack (...)
 *  - Arguments in line [...]
 *  - Code in line with jump around {...}
 * 
 * alt: type operation = ((unit -> unit) * string)
 *)
type operation =

  (* Stack (argv) *)

  | Mark
  | Word (* [string] *)
  | Popm (* (value) *)
  | Count (* (name) *)
  | Concatenate (* (left, right) *)
  | Stringify (* (name) *)

  (* Globbing *)

  | Glob (* ?? *)

  (* Variable *)

  | Assign (* (name, val) *)
  | Dollar (* (name) *)
  | Index  (* ??? *)
  | Local (* (name, val) *)
  | Unlocal (* ?? *)

  (* Functions *)
  | Fn (* (name){... Xreturn } *)
  | DelFn (* (name) *)
  (* less: RdFn *)

  (* Process! *)

  | Simple (* (args) *)

  (* Control part 1 *)

  | Exit 
  | Return

  (* Control part 2 *)

  | If 
  | IfNot
  | Jump  (* [addr] *)
  (* While are compiled in jumps *)  
  | Match (* (pat, str) *)
  | Case  (* (pat, value){...} *)
  | For   (* (var, list){... Xreturn} *)

  (* Boolean return status  *)

  | Wastrue
  | Bang
  | False (* {...} *)
  | True  (* {...} *)

  (* Redirections *)

  | Read (* (file)[fd] *)
  | Write (* (file)[fd] *)
  | ReadWrite (* (file)[fd] *)
  | Append (* (file)[fd] *)
  | Close  (* [fd] *)
  | Dup    (* [fd0 fd1] *)

  (* Pipes *)

  | Pipe (* [i j]{... Xreturn}{... Xreturn} *)
  | PipeWait
  | PipeFd (* [type]{... Xreturn} *)

  (* Error management *)
  | Error
  | Eflag

  (* ?? *)

  | Subshell (* {... Xexit} *)
  | Backquote (* {... Xreturn} *)
  | Async     (* {... Xreturn} *)

  | REPL

type opcode =
  | F of operation
  | I of int
  | S of string

type codevec = opcode array
