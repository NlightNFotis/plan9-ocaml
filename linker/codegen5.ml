(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

open Ast_asm5
module T = Types
module T5 = Types5

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* ARM code generation.
 *
 * No need for optab/oplook/ocmp/cmp as in 5l. Just use pattern matching!
 *)

(*****************************************************************************)
(* Types and constants *)
(*****************************************************************************)

(* more declaratif and give opportunity to sanity check if overlap *)
type composed_word = (int * int) list

type mem_opcode = LDR | STR

type pool =
  | PoolOperand of int
  | LPOOL (* todo: still don't know why we need that *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let error loc s =
  failwith (spf "%s at %s" s (T5.s_of_loc loc))

let offset_to_R12 x =
  (* less: x - BIG at some point if want some optimisation *)
  x

let base_and_offset_of_indirect loc symbols2 autosize x =
  match x with
  | Indirect (r, off) -> r, off 
  | Param (_s, off) ->
      (* remember that +4 here is because we access the frame of the
       * caller which for sure is not a leaf. Note that autosize
       * here had possibly a +4 done if the current function
       * was a leaf, but still we need another +4 because what matters
       * now is the adjustment in the frame of the caller!
       *)
      rSP, autosize + 4 + off
  | Local (_s, off) -> 
      rSP, autosize + off
  | Entity (ent, off) ->
      let v = Hashtbl.find symbols2 (T5.symbol_of_entity ent) in
      (match v with
      | T.SData2 offset | T.SBss2 offset -> 
          rSB, offset_to_R12 (offset + off)
      (* stricter: allowed in 5l I think but wrong codegen I think *)
      | T.SText2 _ -> 
          error loc (spf "use of procedure %s in indirect with offset"
                       (T5.s_of_ent ent))
      )
  | Imsr _ | Ximm _ -> raise (Impossible "should be called only for indirects")

(*****************************************************************************)
(* Operand classes *)
(*****************************************************************************)

let immrot x =
  if x >= 0 && x <= 0xff
  then Some (0, x)
  else raise Todo

let immoffset x =
  (x >= 0 && x <= 0xfff) || (x < 0 && x >= -0xfff)
(* job done already by gmem
  match () with
  | _ when x >= 0 && x <= 0xfff -> Some [(1, 24); (1, 23); (v, 0)]
  | _ when x < 0 && x >= -0xfff -> Some [(1, 24); (0, 23); (-v, 0)]
  | _ -> None
*)

(*****************************************************************************)
(* Code generation helpers *)
(*****************************************************************************)

(* gxxx below means gen_binary_code of xxx *)

let gcond cond =
  match cond with
  | EQ            -> (0x0, 28)
  | NE            -> (0x1, 28)
  | GE (Unsigned) -> (0x2, 28)
  | LT (Unsigned) -> (0x3, 28)
  | MI            -> (0x4, 28)
  | PL            -> (0x5, 28)
  | VS            -> (0x6, 28)
  | VC            -> (0x7, 28)
  | GT (Unsigned) -> (0x8, 28)
  | LE (Unsigned) -> (0x9, 28) 
  | GE (Signed)   -> (0xa, 28) 
  | LT (Signed)   -> (0xb, 28)
  | GT (Signed)   -> (0xc, 28)
  | LE (Signed)   -> (0xd, 28)
  | AL            -> (0xe, 28)
  | NV            -> (0xf, 28)


let gop_arith op =
  match op with
  | AND -> (0x0, 21)
  | EOR -> (0x1, 21)
  | SUB -> (0x2, 21)
  | RSB -> (0x3, 21)
  | ADD -> (0x4, 21)
  | ADC -> (0x5, 21)
  | SBC -> (0x6, 21)
  | RSC -> (0x7, 21)
  (* TST 0x8, TEQ 0x9, CMP 0xa, CMN 0xb via gop_cmp below *)
  | ORR -> (0xc, 21)
  | MOV -> (0xd, 21) (* no reading syntax in 5a, but can be generated by 5l *)
  | BIC -> (0xe, 21)
  | MVN -> (0xf, 21)

  | MUL | DIV | MOD -> raise (Impossible "should match those cases separately")
  | SLL | SRL | SRA -> raise (Impossible "should match those cases separately")
  
let gsetbit opt =
  match opt with
  | None -> []
  | Some Set_condition -> [(1, 20)]
  

let gop_shift op =
  match op with
  | SLL -> (0, 5)
  | SRL -> (1, 5)
  | SRA -> (2, 5)
  | _ -> raise (Impossible "should match those cases separately")


let gop_cmp op =
  match op with
  (* Set_condition set by default for comparison opcodes *)
  | TST -> [(0x8, 21); (1, 20)]
  | TEQ -> [(0x9, 21); (1, 20)]
  | CMP -> [(0xa, 21); (1, 20)]
  | CMN -> [(0xb, 21); (1, 20)]

let gop_bitshift_register op =
  match op with
  | Sh_logic_left   -> (0x0, 5)
  | Sh_logic_right  -> (0x1, 5)
  | Sh_arith_right  -> (0x2, 5)
  | Sh_rotate_right -> (0x3, 5)

let gop_rcon x =
  match x with
  | Left (R r) -> [(r,8); (1, 4)]
  | Right i    -> [(i, 7); (0, 4)]

let gshift (R rf) op2 rcon = 
  gop_rcon rcon @ [gop_bitshift_register op2; (rf, 0)]


let gbranch_static {T5. loc; branch; real_pc = src_pc } cond is_bl =
  match branch with
  | None -> raise (Impossible "resolving should have set the branch field")
  | Some n -> 
      let dst_pc = n.T5.real_pc in
      let v = (dst_pc - src_pc) - 8 in
      if v mod 4 <> 0
      then raise (Impossible "layout text wrong, not word aligned node");
      let v = v asr 2 in
      (* todo: stricter: warn if too big, but should never happens *)
      
      [gcond cond; (0x5, 25);
       (if is_bl then (0x1, 24) else (0x0, 24)); 
       (v,0) 
       ]




let gmem cond op move_size opt offset_or_rm (R rbase) (R rt) =
  [gcond cond; (0x1, 26) ] @
  (match opt with
  | None ->                  [(1, 24)] (* pre offset write *)
  | Some PostOffsetWrite ->  [(0, 24)]
  | Some WriteAddressBase -> [(1, 21)]
  ) @
  [(match move_size with 
   | Word -> (0, 22) 
   | Byte _ -> (1, 22) 
   | HalfWord _ -> raise (Impossible "should use different pattern rule")
   );
   (match op with 
    | LDR -> (1, 20) 
    | STR -> (0, 20)
   );
   (rbase, 16); (rt, 12);
  ] @
  (match offset_or_rm with
  | Left offset -> 
      if offset >= 0 
      then [(1, 23); (offset, 0)]
      else [(0, 23); (-offset, 0)]
  | Right (R r) -> [(1, 25); (r, 0)]
  )

(*****************************************************************************)
(* The rules! *)
(*****************************************************************************)

type action = {
  size: int;
  pool: pool option;
  binary: unit -> composed_word list;
}

(* conventions (matches the one used (inconsistently) in 5l):
 * - rf = register from (called Rm in refcard)
 * - rt = register to   (called Rd in refcard)
 * - r  = register middle (called Rn in refcard)
 *)
let rules symbols2 autosize node =
  let loc = node.T5.loc in
  match node.T5.node with
  (* --------------------------------------------------------------------- *)
  (* Pseudo *)
  (* --------------------------------------------------------------------- *)

  (* TEXT instructions were kept just for better error reporting localisation *)
  | T5.TEXT (_, _, _) -> 
      { size = 0; pool = None; binary = (fun () -> []) }

  | T5.WORD x ->
      { size = 4; pool = None; binary = (fun () -> 
        match x with
        | Left i -> [ [(i, 0)] ]
        | Right (String s) -> raise Todo
        | Right (Address ent) -> 
            let v = Hashtbl.find symbols2 (T5.symbol_of_entity ent) in
            (match v with
             | T.SText2 real_pc -> [ [real_pc, 0] ]
             | T.SData2 offset | T.SBss2 offset -> 
                 (* need initdat *)
                 raise Todo
            )
        )
      }

  | T5.I (instr, cond) ->
    (match instr with

    (* --------------------------------------------------------------------- *)
    (* Arithmetics *)
    (* --------------------------------------------------------------------- *)
    | Arith ((AND|ORR|EOR|ADD|SUB|BIC|ADC|SBC|RSB|RSC|MVN|MOV) as op, opt,
             from, middle, (R rt)) ->
        let r =
          if op = MVN || op = MOV
          then 0
          else 
            match middle with 
            | None -> rt 
            | Some (R x) -> x 
        in
        let from_part =
          match from with
          | Reg (R rf)      -> [(rf, 0)]
          | Shift (a, b, c) -> gshift a b c
          | Imm i ->
              (match immrot i with
              | Some (rot, v) -> [(1, 25); (rot, 8); (v, 0)]
              | None -> raise Todo
              )
        in
        { size = 4; pool = None; binary = (fun () ->
          [[gcond cond; gop_arith op] @ gsetbit opt @ [(r, 16); (rt, 12)] 
            @ from_part]
        )}

    (* SLL I, [R], RT -> MOV (R << c), RT *)
    | Arith ((SLL|SRL|SRA) as op, opt, from, middle, (R rt)) ->
        let r = 
          match middle with 
          | None -> rt 
          | Some (R x) -> x 
        in
        let from_part = 
          match from with
          | Imm i ->
              if i >= 0 && i <= 31
              then [(i, 7)]
              (* stricter: failwith, not silently truncate *)
              else error loc (spf "shit value out of range %d" i)
          | Reg (R rf) -> [(rf, 8); (1, 4)]
          (* stricter: I added that *)
          | Shift _ -> error loc "bitshift on shift operation not allowed"
        in
        { size = 4; pool = None; binary = (fun () ->
          [[gcond cond; gop_arith MOV] @ gsetbit opt @ [(rt, 12); gop_shift op]
            @ from_part @ [(r, 0)]]
        )}

    | Arith (MUL, opt, from, middle, (R rt)) ->
        let rf =
          match from with
          | Reg (R rf) -> rf
          (* stricter: not stricter but better error message at least *)
          | Shift _ | Imm _ ->
              error loc "MUL can take only register operands"
        in
        let r = 
          match middle with 
          | None -> rt 
          | Some (R x) -> x 
        in
        (* ?? *)
        let (r, rf) = if rt = r then (rf, rt) else (r, rf) in
        
        { size = 4; pool = None; binary = (fun () ->
          [[gcond cond; (0x0, 21)] @ gsetbit opt 
            @ [(rt, 16); (rf, 8); (0x9, 4); (r, 0) ]]
        )}
        


    | Cmp (op, from, (R r)) ->
        let from_part = 
          match from with
          | Reg (R rf) -> [(rf, 0)]
          | Shift (a, b, c) -> gshift a b c
          | Imm i ->
              (match immrot i with
              | Some (rot, v) -> [(1, 25); (rot, 8); (v, 0)]
              | None -> raise Todo
              )
        in
        { size = 4; pool = None; binary = (fun () ->
          [[gcond cond] @ gop_cmp op @ [(r, 16); (0, 12)] @ from_part]
        )}
        
    | MOVE (Word, None, Imsr from, Imsr (Reg (R rt))) -> 
        let from_part = 
          match from with
          | Reg (R rf) -> [(rf, 0)]
          | Shift (a, b, c) -> gshift a b c
          | Imm i ->
              (match immrot i with
              | Some (rot, v) -> [(1, 25); (rot, 8); (v, 0)]
              | None -> raise Todo
              )
        in
        { size = 4; pool = None; binary = (fun () ->
          [[gcond cond; gop_arith MOV; (0, 16); (rt, 12)] @ from_part]
        )}

    (* MOVBU R, RT -> ADD 0xff, R, RT *)
    | MOVE (Byte Unsigned, None, Imsr (Reg (R r)), Imsr (Reg (R rt))) -> 
        { size = 4; pool = None; binary = (fun () ->
          [[gcond cond; (1, 25); gop_arith AND; (r, 16); (rt, 12); (0xff,0)]]
        )}

    (* MOVB RF, RT  -> SLL 24, RF, RT; SRA 24, RT, RT -> MOV (RF << 24), RT;...
     * MOVH RF, RT  -> SLL 16, RF, RT; SRA 16, RT, RT -> ...
     * MOVHU RF, RT -> SLL 16, RF, RT; SRL 16, RT, RT -> 
     *)
    | MOVE ((Byte _|HalfWord _)as size, None, Imsr(Reg(R rf)),Imsr(Reg(R rt)))->
        let rop =
          match size with
          | Byte Unsigned | HalfWord Unsigned -> SRL
          | Byte Signed   | HalfWord Signed -> SRA
          | Word -> raise (Impossible "size matched in pattern")
        in
        let sh =
          match size with
          | Byte _ -> 24
          | HalfWord _ -> 16
          | Word -> raise (Impossible "size matched in pattern")
        in
        { size = 8; pool = None; binary = (fun () ->
          [
            [gcond cond; gop_arith MOV; (rt, 12); gop_shift SLL; (sh,7);(rf,0)];
            [gcond cond; gop_arith MOV; (rt, 12); gop_shift rop; (sh,7);(rt,0)];
          ]
        )}


    (* --------------------------------------------------------------------- *)
    (* Control flow *)
    (* --------------------------------------------------------------------- *)
    | B x ->
        if cond <> AL 
        then raise (Impossible "B should always be with AL");
        { size = 4; pool = Some LPOOL; binary = (fun () ->
          match !x with
          | Absolute _ -> [ gbranch_static node AL false ]
          (* B (R) -> ADD 0, R, PC *)
          | IndirectJump (R r) ->
              let (R rt) = rPC in
              [ [(1, 25); gop_arith ADD; (r, 16); (rt, 12); (0, 0)] ]
          | _ -> raise (Impossible "5a or 5l should have resolved this branch")
        )}
    | BL x ->
        (match !x with
        | Absolute _ -> 
            { size = 4; pool = None; binary = (fun () ->
              [ gbranch_static node AL true ]
            )}
        (* BL (R) -> ADD 0, PC, LINK; ADD 0, R, PC *)
        | IndirectJump (R r) ->
           { size = 8; pool = None; binary = (fun () ->
             let (R r2) = rPC in
             let (R rt) = rLINK in
              [ 
                (* remember that when PC is involved in input operand
                 * there is an implicit +8 which is perfect for our case
                 * here
                 *)
                [(1, 25); gop_arith ADD; (r2, 16); (rt, 12); (0, 0)];
                [(1, 25); gop_arith ADD; (r, 16); (r2, 12); (0, 0)];
              ]
             )}
        | _ -> raise (Impossible "5a or 5l should have resolved this branch")
        )

    | Bxx (cond2, x) ->
        if cond <> AL 
        then raise (Impossible "Bxx should always be with AL");
        (match !x with
        | Absolute _ -> 
            { size = 4; pool = None; binary = (fun () ->
              [ gbranch_static node cond2 true ]
            )}
        (* stricter: better error message at least? *)
        | IndirectJump _ -> error loc "Bxx supports only static jumps"
        | _ -> raise (Impossible "5a or 5l should have resolved this branch")
        )

    (* --------------------------------------------------------------------- *)
    (* Memory *)
    (* --------------------------------------------------------------------- *)

    (* Load *)

    | MOVE ((Word | Byte Unsigned) as size, opt, from, Imsr (Reg rt)) ->
        (match from with
        | Imsr (Imm _ | Reg _) -> raise (Impossible "pattern covered before")
        | Imsr (Shift _) -> raise Todo
        | Ximm _ -> raise Todo
        | Indirect _ | Param _ | Local _ | Entity _ ->
            let (rbase, offset) = 
              base_and_offset_of_indirect loc symbols2 autosize from in
            if immoffset offset
            then
              { size = 4; pool = None; binary = (fun () -> 
                [ gmem cond LDR size opt (Left offset) rbase rt ]
              )}
            else
              raise Todo
        )

    (* Store *)

    (* note that works for Byte Signed and Unsigned here *)
    | MOVE ((Word | Byte _) as size, opt, Imsr (Reg rf), dest) ->
        (match dest with
        | Imsr (Imm _ | Reg _) -> raise (Impossible "pattern covered before")
        | Imsr (Shift _) -> raise Todo
        | Ximm _ -> raise Todo
        | Indirect _ | Param _ | Local _ | Entity _ ->
            let (rbase, offset) = 
              base_and_offset_of_indirect loc symbols2 autosize dest in
            if immoffset offset
            then
              { size = 4; pool = None; binary = (fun () -> 
                [ gmem cond STR size opt (Left offset) rbase rf ]
              )}
            else
              raise Todo
        )

    (* Swap *)

    (* Address *)

    (* Half words and signed bytes *)

    (* --------------------------------------------------------------------- *)
    (* System *)
    (* --------------------------------------------------------------------- *)
    | SWI i ->
        if i <> 0
        then error loc (spf "SWI does not use its parameter under Plan9");
        { size = 4; pool = None; binary = (fun () ->
          [ [gcond cond; (0xf, 24)] ]
        )}
    (* RFE -> MOVM.S.W.U 0(r13),[r15] *)
    | RFE ->
        { size = 4; pool = None; binary = (fun () -> 
          [ [(0xe8fd8000, 0)] ]
        )}

    (* --------------------------------------------------------------------- *)
    (* Other *)
    (* --------------------------------------------------------------------- *)
    | _ -> error loc "illegal combination"
    )

(*****************************************************************************)
(* entry points *)
(*****************************************************************************)

let size_of_instruction symbols2 autosize node =
  let action  = rules symbols2 autosize node in
  action.size, action.pool



let gen_one cg instr =
  (* todo: can sanity check size and list are the same *)
  raise Todo


(* TODO: double check pc is like one computed by layout_text 
   otherwise failwith  "phase error ..."
*)
let gen symbols cg =
  (* todo: need also update autosize *)
  raise Todo


